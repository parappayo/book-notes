
# About

* [The Psychology of Computer Programming](https://geraldmweinberg.com/Site/Programming_Psychology.html)
* by Gerald Weinberg
* Van Nostrand Reinhold, 1971

# Thoughts

Fantastic read, rich in ideas, full of truth. It is incredible how little has changed in 50+ years.

Note that not all bibliography books are included here. There are lots of citations in the book.

# Take-Aways

* All laws have limits; the limits are typically more important to know than the laws themselves
* Discussions may failure to distinguish between professional and hobby programming
* Once people have a new perspective, they will implement improvements on their own
* "Many college-trained developers approach a project like a one-semester class assignment. They think about it or ignore it for a while, then suddenly start jamming on the keyboard to produce something that will earn a passing grade. Software projects done at universities generally don’t have to be maintainable, usable, or testable by another person."
* These days the goal tends to be value delivered to a customer rather than program efficiency; runtime is typically cheap
* "There probably is, in almost every program, some code which actually does the work that was specified" / "even if we succeed in extracting this kernel of the program, we must not be misled into the illusion that we could have started with this kernel as a specification" / "in most cases, we do not know what we want to do until we have taken a flying leap at programming it" / "writing a program is a process of learning"
* The code that is most frequently read is typically problematic code (a bug may have lead the reader there); if a coder doesn't know what good code looks like, they may fail to lean good practices from reading code; the good get better, the bad get worse
* "When a patient recovers, it is the work of the doctor; when a patient dies, it is an act of God. But when a computer program doesn’t work, everyone knows—and everyone knows who is to blame."
* "more than twenty-five years ago I conducted a survey of the women programmers in my advanced software development class. When I asked these students about their experiences working on teams with other women, none of them could answer—because none had ever worked on a team with another woman programmer. Forty years ago, our typical PSL class might have as many as four women out of twenty-four participants; more likely to be eight-to-twelve out of twenty-four."
* "the professional is very tired and a bit irritated by the unending stream of amateurs waving their printouts in her face and condemning the machine, the operator, the system, the keypuncher, the language, or the government. The amateur, on the other hand, can see that the professional does not even care that his means and standard deviations are not going to be ready in time for inclusion in the proceedings of the conference"
* adjust your level of rigor to the task at hand; neither under nor over engineer
* the first and last letters of a word tend to have strong influence over it being recognized than the other letters
* learners often mistake a problem for being easier or harder than it is; bad teachers frequently either make a problem domain out to be either much easier or much harder than it is; by making too many simplifying assumptions, the student cannot deal with practical applications; on the other hand, by diving too much into difficult technicalities, the student is discouraged
* the first step in learning is to understand one's own assets and liabilities
* "something that is not right is wrong" - fallacy imposed by typical education's need for testable knowledge
* Sept 1962 news story alleges that an $18M rocket was destroyed because of a missing hyphen in a roll of instruction tape; there are no "small" errors in programming, the size of the error does not correlate to the scale of the damage caused
* an expert avoids the small errors while sweeping toward the grand fallacy
* in order to maintain alertness, radar systems introduce some artificial events so that human operators have something to watch out for
* uniform code responds better to tests; the more branches and variation there is, the less confidence a single test provides
* there is a psychological bias toward early results; programmers testing their own software tend to give up early; people tend to fixate on code where they've found an error before, it's important to coax devs into looking at rarely inspected code as well
* the low status perception of software testers remain social issues
* it's not until you turn your head that you realize how sharp the razor was


## On Programmers

* Decades long efforts to eliminate programmers from the software business have failed; typically such schemes are invented by programmers
* Programming has a mystique, often not well understood; some programmers encourage this, so execs seek to mitigate the human factors
* good programmers are made, not born
* shy amateurs and arrogant experts often have in common that they are overly reluctant to seek help
* "A programmer who truly sees his program as an extension of his own ego is not going to be trying to find all the errors in that program."
* "since the machine is so inflexible, the programmer must be flexible enough to supply the elasticity needed in matching any system’s abilities to real world needs"
* a large portion of the variance in software quality delivery can be attributed to differences between programmers in understanding what work is being asked for
* software design, implementation, testing, documentation, and management all require different talents, yet there is a tendency to see "coding skill" as a singular, all-important talent; sometimes these stages are planned to happen in order even though in practice they do not
* developer mindset and environment varies day-to-day; having a variety of types of work (coding, documentation, testing) allows devs to stay productive; forcing types of work into phases interferes
* programmers sometimes quit immediately after getting a raise; the increase in compensation may be perceived as extra pressure to perform well, or may be perceived as being granted in lieu of something the dev really wants
* "If a programmer is indispensable, get rid of him as quickly as possible."
* "The same talents or personality that make a person an excellent amateur programmer may make him singularly unsuited for being a professional one; but the lack of ability to adjust his working behavior to the problem at hand will always make him unsuited."
* when devs encounter a problem with an approach, efficiency-focused devs tend to stick with the current approach and fix the problem, whereas devs focused on fast delivery tend to substitute another approach thus sacrificing program efficiency; the efficiency-focused team may stick with a doomed approach much longer than "get it working now" teams
* dev roles put pressure on personality traits, changes in role offer relief; assigning roles based on perceived personality traits is dangerous; inner personality often differs from what manifests on the surface
* "Although the average programming manager would say that intelligence is more important than personality in programming success, very few could cite cases of people who turned out not to be intelligent enough to program, but everyone knows of cases of people who were not temperamentally suited to the programmer’s job."
* people who spend a lot of time solving other people's problems quickly learn not to listen to the explanation of the person who already failed to solve it since that just leads one down the same dead-end path
* forcing a person to think in another person's style reduces their problem solving ability
* a programmer's work is not done when the program "works;" that is an important time to ask questions and learn
* the diversity of schooling has decreased among computer programmers, people tend to have more similar backgrounds (science, engineering)
* some people are easily distracted while studying, others actually require some noise to learn effectively
* computer professionals sometimes have a reputation for being rigid people, but actually they often have to be atypically flexible to make up for the lack of accommodation on the part of the computer
* good people can write bad systems
* the more that programmers run into constraints, the more they start to anticipate constraints that aren't actually there
* every programmer is a meta-language expert

## On Managers

* "Basic principle of the psychology of management: Managers who pay attention to people get good results"
* Bad managers ask for everything; "It’s as if they think all you have to do to manage the New York Yankees is tell every batter to hit a home run, and every pitcher to strike the batter out."
* managers who demand efficient programs often balk at the cost of changes; managers who demand adaptable programs often accept some sacrifice in performance
* "Nobody can seriously have believed that executives could read programs. Why should they? Even programmers do not read programs."
* managers often attribute group performance to an individual genius rather than being a property of the group; managers often see the team as a brittle structure that will fail if a key member is removed, rather than as a continuum that should outlive its members; this perceived brittleness is often a self-fulfilling prophecy
* managerial psychology often puts social status ahead of productivity
* managers press hard for promises but what they really want are results
* managers may be selected for their willingness to make promises to upper management and may be promoted before it becomes clear that those promises will not be met
* managers are often caught by surprise when a team's performance suffers after losing a team member that was perceived to be unproductive
* "Whenever a supervisor is responsible for work he does not understand, he begins to reward workers not for work, but for the appearance of work." / "Programmers who are observed talking to others are not considered to be working, because the manager has an image that programming work involves the solitary thinker scratching out secret messages to the computer."
* "there is a certain type of leading which is only a crystallization of deep-seated desires many onto the personality of one. In programming, this is scarcely the type of leadership needed"
* it is crucial that leadership be allowed to emerge from the expertise relevant to the current situation; democracy allows for this kind of adaptation, but is not realistic on programming teams
* a team leader may make promises based on an assurance that new resources will be provided (additional headcount, better hardware) only to find that those new resources are not delivered
* "the number one mistake I’ve seen in team formation over the years is adding members to a team based on some presumed skill, rather than on compatibility of the new members with the rest of the team members. Skill may be hard to come by, but it’s always easier to buy or train than compatibility."
* when people know they are being measured but do not get to see the data, they tend to experiment by varying their performance to see what reaction they get
* bad management may have the attitude that "school is where people learn, the office is where people work," but this has disastrous consequences for tech work
* motivation and training are factors in programmer performance, but typically neither is well understood; bad management often mistakes a lack of perf for a lack of motivation

## On Teams

* tightly knit teams often leave jobs together not as a conspiracy but because it's in each individual's interest
* "The lack of experience in programming becomes more evident as the size of the system to be produced increases."
* rule of thumb: three programmers are twice as productive as one, three groups of three programmers are only about twice as productive as one group (or four times as productive as one programmer)
* "the worst way to do a programming project is to hire a horde of trainees and put them to work under pressure and without supervision—although this is the most common practice today" ; "More common today is the second worst way to do a programming project: Hire a miscellaneous horde of contractors (who may actually be trainees in disguise) and put them to work under pressure and without supervision. Or with over-supervision."
* some programming tasks are seen as less prestigious than others, drama ensues; egoless attitudes help
* when one member of the group does not share the group goals it is perceived by others and lowers the productivity of all
* group consensus is more readily achieved by enabling the team to set their own goals
* support teams may tend to drift into fascinating but useless projects unless given persistent, focused direction
* people underestimate how varied software development is in terms of problem domain, tools employed, and in skills required; it takes a community
* a good learning environment may provide anonymity to encourage people to make mistakes

## On Studies

* Past studies focused on programming as an individual activity, not a social activity; devs spend 2/3rd of their time working with others
* study what people do rather than what they think they do; observation tells us what people do, but not what they can do
* historically, studying programmer behaviour was costly because computer systems and the time of computer programmers were both expensive
* knowing what to measure is a problem; a sociologist can use knowledge of their own culture to construct a reasonable questionnaire, but an anthropologist is harder pressed to know what to ask
* "psychology is the psychology of 18-year-old college freshmen" - common population bias in studies
* studies of dev performance often focus on one type of work, eg. analytical work (tracing bugs) or synthetic work (coding), such that there isn't a good overall view of a given dev's ability to contribute to a realistic project; at best you're studying how helpful a dev is at one phase of a project
* social psychologists have often studied group dynamics under situations that only last for days or weeks, whereas programming team situations may last months or years
* many studies of programmer problem solving do not consider the quality of the solutions produced by subjects; either a problem is solved or not
* studying mistakes is challenging because trial subjects frequently try to hide them

## On Optimizations

* Software optimizations by relaxing the spec may come at the cost of people time, can easily be a net negative; eg. consider a program that is 20% faster but needs to be re-run 50% of the time
* "We have long since passed the point where the typical installation spends more money on programming than it does on production work. This imbalance is even more striking when all the work improperly classified as “production” is put under the proper heading of “debugging.”"
* Whether it is an efficiency gain to consume more memory to save runtime depends on the execution environment and can vary rapidly over time; dynamic load balancing needs to consider that users may be more sensitive to standard deviation than mean execution time
* Evaluating a compiler by the rate of instructions generated per minute may simply reward compilers that produce verbose object code; source code lines processed per minute is similarly misleading
* Typically a compiler that omits 10% of a language's features can compile code 50% faster; which 10% varies by architecture
* "When the programmer includes something that is intended to overcome some limitation of the machine, he rarely marks it explicitly as such"

## On Tools

* the poor workman hates his tools, the good workman hates poor tools
* there are more compiler builders in the world than needed; the rate of new langs has accelerated as the industry has grown
* superior tools prolong the life of inferior langs
* the rise of the PC in the 1980s democratized software tools development
* langs need to take people into account, not just math foundations and hardware concerns
* langs are a notation, not natural language, but we see programming as communication between man and machine, hence "language"
* lang design must consider workflow, not merely code reliability
* adaptable langs accommodate the preferences of different devs, but the more we fit the language to our own mental model the further it strays from the understandings of our colleagues
* special purpose langs facilitate understanding because they narrow the universe of discourse, ideally to only encompass what is relevant; this is a double-edged sword, the limitations can blind the user to solutions that would be obvious in other tools
* the tools we know shape how we approach problems; while teaching a PL/I course, the instructor was able to guess with fair accuracy whether the student came from a COBOL, FORTRAN, assembler, or "none" background based on how they approached the first assignment
* to responsibly develop a new lang, one has to function as a professional designer as well as a professional programmer
* for langs to see adoption, designers must be more students of human behaviour than students of symbol manipulation
* not just langs; programmers use tools for documentation, debugging, operations
* the only real problem in programming is getting the program to work correctly and proving it
* increased flexibility in a system often allows people to optimize their own workflow
* any tool effective for getting people unstuck is a useful debugging tool
* viewing the code in a novel way may yield insights, eg. change formatting, collapse at a level of nesting, have comments / annotations in a separate window, rename identifiers; consider the painter who views a reference upside down to disturb their perception of it
* the "personality" that a UI presents affects how people use that system
* software dev tools (not just langs) have come a long way: code coverage analyzers, test harnesses, specification langs, static and dynamic structure analyzers
* designers (of systems and processes) too often act on instinct rather than gathering evidence
* people are so adaptable that they'll learn to use almost any system interface no matter how terrible
* be wary of convenient tools that are error prone; ease of implementation may be a false economy when the rate of programmer error is higher
* very slow build times may allow diligent programmers extra time to review their code for errors and incentivizes careful programming
* early time sharing systems were seen by some engineers as a marketing gimmick to introduce inefficiency into computing systems and sell more runtime

## On Documentation

* "documentation is the castor oil of programming," devs hate it but their managers say it's good for them
* poor documentation is worse than no documentation
* documentation for a Fortran program should assume that the reader knows Fortran
* a document intro should have enough detail for the reader to know whether or not they will find the document useful (what level of knowledge is assumed), and have references to both higher level and lower level documents for readers who need less or more technical detail
* consider that documentation may help guide experimentation by giving devs enough context to know what changes to try in order to better understand the system
* Klerer and May advocate for the code is the doc; rather than trying to capture every subtle detail about the system in doc, the docs are a general guide and the code itself can be referred to for fine details
* the machine is the final authority on documentation disputes

# Concepts

* "Mind your p's and q's" - a common manual typesetting error is to transpose letters
* Accidental Complexity - not inherent to the problem being solved; can be mitigated with psychological change
* Activity Vector Analysis - programmer personality test
* Agile Programming - can be thought of as "egoless teams"
* Amateur Programming (Hobbyists) - unlike professionals, amateurs typically control their own spec, write programs that only they themselves use, and have more control over their dev environment (tools, conventions)
* American Accents - Atlanta "pie," Omaha "milk," Boston "yard"
* Array Expressions - a feature of PL/I
* Assembler - produces assembly code, frees the programmer of housekeeping tasks like counting clock cycles, calculating relative addresses, manually looking up ops codes, etc.
* Austrian Army - in the 19th century, saw success through hierarchical organization, soldiers are seen as interchangeable; this model is still imitated today but often a project team is more like an engine with parts that cooperate than a pyramid structure for ambitious individuals to climb
* Authoritarian Team - work is organized and guarded by the appointed leader; seems warm and friendly, is fragile, team members don't need to get along with each other, just get along with the leader; groups in crisis tend to be more accepting of strong leadership but more impatient with perceived incompetent leadership
* Bebugging - opposite of debugging, agent introduces logic errors to motivate maintainers to search for error cases
* Bit-Picking - when management gets involved in technical implementation details; may come from a desire to be precise and mistaking precision for clarity
* Blame-Analysis - find the person at fault for the problem; motivates people to hide the true cause
* Blanks Error - a type of punch-card error commonly made by JCL novices
* Bomb-Out - archaic operator term for a system panic
* Broadcast Transmission and Directional Reception - when we speak it is in all directions at once but people can tell where the speaker is
* CAI - Computer Aided Instruction
* Card File - for securing punch cards, apparently
* Chief Programmers - HD Mills suggested a programming team structured like a surgical team, with a surgeon and specialized assistants; Weinberg warns about this being a potentially dysfunctional model
* Chunking - mental re-coding process where people naturally group, shorten, or summarize information to make it easier to keep in-mind
* Clarity / Readability - not just maintainability, also how well ideas are transmitted; limitations affecting clarity include hardware limits (memory, performance), language / tooling (work-arounds, boilerplate), programmer limits (mastery of the dev environment, misunderstandings), historical accidents, essential complexity; often these are past limitations, the code would have been written differently today and that may drive jr devs to resent sr staff
* Code Ownership - tends to make the bus factor worse
* Cognitive Dissonance - when acting against one's self-interest, something has to yield but it is unlikely to be the person's self-image; programmers tend to be bad at testing their own work; when code is found to be defective, a programmer with a strong sense of ownership over it may feel attacked; somebody who has just bought a Ford will pay more attention to Ford ads than Chevy ads
* Community - high functioning tech orgs operate as a community
* Compactness - concise code is easier to test, repetition invites variation
* Compactness - minimize the mental load on developers; Weinberg studies suggest that the presence of comments make programs less readable regardless of how useful the comments are simply because the program text gets longer; not about the number of characters, but rather the number of mental chunks
* Compactness - subroutines and data structuring are common lang mechanisms to improve the compactness of code
* Conway's Law - would make sense to plan the ideal program structure and assemble the right team to build it, but typically teams are stuck with available dev resources, so the program design follows from the team composition instead
* Correctness - above all other concerns, code needs to solve the problem; efficient, elegant code doesn't matter if it arrives at the wrong answer
* Cramer's Rule - for solving systems of equations; frequently taught to beginners but impractical for large systems of equations, the calculation of determinants grows rapidly in complexity
* Crisis - tech provides many situations for team crises to emerge; eg. system outage, bugs, change in specs, management changes
* Dead-End Technique - learned to solve some problem but rapidly becomes impractical beyond beginner level applications
* Deadlines - planning around a deadline and granting an extension results in a longer timeline than if the work had been planned to take longer from the outset; slipped deadlines often start with plans that assume optimal conditions; generally accepted that software projects always run over time, but fallacies underlie this belief
* Democratic Team - organized by group consensus, sets its own goals, shares responsibilities, leadership is fluid, may seem surprisingly cold to outsiders, adaptable; tech teams often like shifts in leadership to allow the expert in the current crisis situation to lead
* Detached - personality trait opposed to compliant or aggressive; often seen as desirable in programmers because it is assumed to be a solitary and creative profession
* Devil's Advocate (Obligation to Dissent) - people are more likely to speak out about a problem if there is an ally in the room; unanimous agreement is often a sign of dishonesty
* Directional Transmission and Broadcast Reception - computers receive programs like heaven receives prayers; from all users all at once, and nobody else gets the messages; the system does not discriminate the information it sends back based on the receiver
* Documentation - good docs are rare, cannot save a poorly written program, takes patience
* Education - artificial learning barriers put in place to direct childhood learning create adults who lack the self-drive to learn; effective learning requires an ability to admit weakness; fear of failure and lack of confidence impede learning
* Egoless Programming - compliant-detached dev culture; ego is a problem for a programmer, leads to fear, increases variance in delivery time; shops that have this culture tend to regard it as a proprietary secret, devs who are job hopping tend not to be coming from this culture; aggressive management culture tends not to appreciate the value of it; this is the most cited, most understood, and most denied idea in the book
* Egoless Programming - lessens the knowledge lost when a dev leaves the project; ego-ful programming remains a major social issue
* Essential Complexity - inescapable complexity of the problem domain
* Estimates - when devs are set an explicit project goal (eg. delivery speed, program efficiency) they tend to be more accurate in their estimates of meeting that goal, but they also tend to work toward that goal at the expense of other goals
* Experiment Design - poorly designed experiments may only be testing the measurement instruments themselves, not any phenomena; studies about problem solving often fail to translate to programming because the problems used in studies are simple enough to have a known, best solution
* Extensible Technique - has applications beyond what it is first learned for
* Factors for the Satisfaction of Working Groups (Team Motivators) - material rewards, challenge, working conditions, status, competence of leadership
* False Consensus - beware a consensus achieved through stifling dissenting opinions
* Fast Fading - natural language is transitory in nature, we forget it as we comprehend it; code does not have a built-in expiry date although it's often useful to have one
* Fisher's Fundamental Theorem of Natural Selection - the better adapted a system is to a given environment, the less adaptable it is to new environments; optimizations often make code less portable, less future proof
* Flow Diagram - seeing how data flows through the system is helpful, especially if a machine-generated diagram (static analysis from source code) can be compared with a dev's mental model for inconsistencies; confusing code with poorly chosen identifiers is often not made any more clear by the addition of a flow diagram
* Forced Labor - "forced labor—to the small extent that it does work—can only be made to work with relatively immature programmers who are not aware of other possibilities, or with relatively unskilled programmers who are quite aware that other possibilities are not open to them"
* Formal Organization - the org chart; some put too much stock in it; mistake to think that this is the only important org structure
* Frequently Asked Questions (FAQ) - Weinberg images a system that would answer questions interactively
* Gestalt - perception of the whole, general feeling
* Greek Drama - success leads to hubris which leads to self-destruction
* Half-Partition - blocks valuable communication but allows distracting noise
* Hawthorne Effect - consider that study subjects change their behaviour merely as a result of being studied; studies at the Hawthorne Works of the Western Electric Company failed to consider that workers under observation increased their productivity out of pride; anthropologists struggle to become invisible to the cultures they visit so that life will continue as normal
* Historical Accidents - hacks to solve problems that have been obscured by time
* Informal Organization - unofficial communication channels; smart management adopts innovations from it, eg. using informal channels can help reduce ticket load
* Inhibition (Psychology) - proactive or retroactive, difficulty learning a new situation because it resembles prior experience; proactive happens when the new rules are confusing because of the old rules, retroactive happens when going back to the old situation and being confused about which rules apply; this is a cost paid when giving a new lang design a familiar face while changing how it works
* Intelligence - less responsive to environment than personality; the industry has pre-selected for applicants who are "intelligent" so we don't really know if less intelligent people could be great devs
* Interchangeability of Language - natural language speakers are typically on similar footing, speak the same lang; with computer code, the programs we input and the format of the output are not the same lang; also, programmers frequently struggle to understand each other's code, also not the same "lang"
* Internet - there's not much point having easy access to information that you didn't want in the first place
* Job Control Procedures - vendors tended to encourage people to use standard procedures rather than writing their own custom ones, but the custom ones were often better optimized to the user's jobs
* Kuder Preference Test - programmer personality test
* Law of Effect - people keep doing things that seemed to work well last time
* Leadership - as defined by social scientists, the ability to influence others
* Levine the Genius Tailor - story, is the tailor a genius or is the customer contorting to fit the suit?; often users bend to the design of the lang rather than vice-versa; changing the behaviour of a computer system typically takes longer than changing the behaviour of a user
* Lifecycle of a Team - recruitment, goal setting, delivery, dissolution or new goals; typically there is a crisis at every step
* Linearity - of programs, helps us leverage human sequential memory; loops and branches defeat this, spaghetti code is highly non-linear
* Locality - of programs, helps us leverage human synthetic memory; well chosen domain boundaries help; flipping back and forth hurts this
* Locality - the more external dependencies a block of code has, and the larger the interface it exposes to other parts of code, the less locality it has
* Macro Lang - allows metaprogramming
* Mad Bomber - arrogant dev who needed code to repeatedly fail before seeing a problem with it, see "Bomb-Out"; reckless devs often become known to system operators
* Maintenance-Oriented Activity - from social psychology, work done by the team to self-sustain, such as resolving conflicts; task and maintenance activities often have different leaders within the group, stereotypically the maintenance leader is the mother figure, often charismatic (see Task-Oriented Activity)
* MetaCOBOL - some initiative to advance COBOL design
* Meyers-Briggs Type Indicator - personality test created in 1980
* Minnesota Multiphasic Personality Inventory (MMPI) - personality test, aims to identify mental illness
* Monitor System - automated system operator, runs multiple jobs; before this, group congregation around the machine was more common
* Motivation - performance factor, not easily explained unlike other factors (understanding, intelligence, personality), psychologists have doubted that it exists; managers may mistake a lack of performance for a lack of motivation; pressure and trying too hard is known to tank perf; devs surveyed about motivation cited wanting more comp, influence, time, not wanting help, prestige
* Myer-Briggs Personality Inventory (MBPI)
* N-th Level Manager - a manager of managers, most contact with the work is through other managers; very different role from a manager of programmers
* ON-unit - feature of PL/I, like a trigger I think; moves error handling routes to the side so that the flow of code is not interrupted by those edge cases
* Operating System - not always software, can refer to the rules and processes followed by human operators submitting jobs through a computer; the human mind normally operates at 10% of its capacity, the rest is overhead for the OS
* Parkinson's Law / Parkinsonianism - work expands to fill the time allotted
* Personal Computer - "terminal" terminology became "PC" and then "terminal" again
* Personality - is not fixed, adapts to environment; difficult to identify the source of a personality change except maybe in retrospect; no formal studies of personality traits needed for programmer success, but anecdotally, resilience to prolonged stress, adaptability to rapid change, neatness, humility, assertiveness, humor
* PERT Chart - Program Evaluation and Review; developed by the US Navy in 1958, part of Critical Path Method (CPM)
* Plus ça Change - "In 1993, I was asked if I was really writing about conversion of an application from Microsoft PC-DOS to Microsoft Windows™. My interrogator was convinced he had been on the project I described, and that I had substituted the names of old machines to protect the guilty party."
* Predictable Delivery - unpredictable delivery is psychologically upsetting; "it is not the mean length of estimated time that annoys people but, rather, the standard deviation in the actual time taken"; managing for quality involves delivering predictably
* Problem Avoiding - preventing a problem is the mark of competence, but it is difficult for management to appreciate how much trouble the org is NOT having
* Problem Solving - requires flexibility to quickly change assumptions; many solutions are easy to derive after an overlooked factor is identified; orgs that praise the "hardest working" devs may be celebrating their worst programmers, who work hard because they make it difficult; a programmer who avoids / prevents a problem is doing a better job than a programmer who causes a problem and then fixes it; there are many ways to arrive at the right answer for the wrong reasons, makes it difficult to judge performance
* Process Reporting - measuring the time a software project takes in each stage of design, analysis, implementation, debugging; when the work is categorized rigidly, it hides the reality that stages often happen out of order, work bleeds from one stage into the next; manager may believe that things happen in sequence because the reporting structure forces that view on the project
* Programmer Aptitude - attempts to test for this have confounded researchers; exists across many dimensions, cannot be reduced to a simple score; tests create artificial time pressure and favour short-term memory, rarely test for the ability to reason about the unexpected; may predict who will excel in training but not necessarily on the job; auditions may be a better evaluation method
* Programmer's Aptitude Test (PAT) - originally created around 1956 at IBM's New York Scientific Computing Center to be administered to job applicants; includes sections on relationship rules for geometric figures, arithmetic reasoning, and number series
* Programmer's National Anthem - "aaaaahhhhh"
* Property-Oriented Programming - tempting to think that a programmer owns his code in the same sense that a painter owns his art, but consider that paintings are typically made to be admired by others whereas most programmers don't intend for others to read their code; appreciation of art is in the beholder, but programs are interpreted by a computer objectively
* Psychological Set - the eye tends to see what it expects, proofreading is hard
* Psychology - the psychology of programmers can be studied in terms of social structure (how individuals relate), material culture (tools), recruitment (how people become programmers), and myths (common beliefs)
* Quality - how to measure? elegance and adaptability cannot be quantified, metrics such as line count, cyclomatic complexity are gameable, performance and adherence to spec cannot be determined merely by reading the code; we try to discuss relative code quality by comparing code listings that solve the same problem
* Reporting vs Measuring - reports are often softened by managers, after several layers of reporting the figures may be so muted that they are no longer representative of anything
* Root-Cause Analysis - introspect on the processes that lead to the problem
* Rorschach Ink Blot Test - personality test
* Self Esteem - "I now recognize that the root of many of these problems is low self-esteem. The cure lies in an environment that boosts self-esteem, not one that destroys it."
* Sequential Memory - helps humans remember what comes next in a sequence, like bars of music or phrases of language; it is not "random access" but rather is aided by replaying a chain of stimulus
* sine qua non - indispensable, essential
* Slack - excess capacity to buffer against contingencies
* Social Fixation - fixation of social structures; once tooling and practices are established, momentum tends to keep them in place; egoless programming is difficult to introduce, relatively easy to maintain
* Specs - "When there are multiple users, there are multiple specifications."
* Standards Group - committee to evaluate work progress; there needs to be a separation between the people involved in doing the work and the people involved in evaluating it; the lines of control should not simply be the lines of reporting in reverse
* Status Symbols - matter a lot, even though we might wish otherwise; in tech these include privileged access, newer equipment
* Strong Vocational Interest Blank - personality test, aims to suggest a career; "Strong" is the name of the creator, "Blank" refers to a form to be filled out
* Synthetic Memory - helps humans remember faces, layouts; fills in the details once we have the gist of it
* Task-Oriented Activity - from social psychology, work done by the team to meet its goals; stereotypically the task leader is the father figure, external facing leader with technical skill (see Maintenance-Oriented Activity)
* Team Mother - sexist term for the maintenance leader see Maintenance-Oriented Activity
* Terminals - terminal programming made it less fashionable to read program listings in the whole
* Test Coverage - cannot be confident in the correctness of the program until every branch has been tried at least once
* Test Program - creating small programs that demonstrate problems is a valuable learning tool
* Thematic Apperception Test (TAT) - personality test
* Thurstone Temperament Schedule - programmer personality test
* Training - lack of training (missing skills) can impede education (acquiring a general understanding)
* Uniformity - consistent rules are easier to grok; the meaning of a syntax should not vary surprisingly by context; Fortran subscript rules are not commonly understood by developers because it has more constraints to remember than PL/I
* Virtual Memory - swap on disk
* Vocal-Auditory Channel - natural written language is strongly influenced by a vocal counterpart, whereas code is often difficult to vocalize
* Zipf's Law - the most commonly used words tend to be the shortest

# Techs

* APL - lang
* BAL - Basic Assembler Language
* BASIC - lang
* COBOL - lang, promised to make code read-able to non-techies
* FORTRAN - lang, stands for "formula translation," sounded too good to be true in 1956; lacks the facility to recognize an end-of-file marker; old versions do not use whitespace as a delimiter, so `DO 33 I = 1, 10` is parsed as "from label 33 loop I from 1 to 10" but `DO 33 I = 1. 10` parses as "assign 1.10 to variable DO33I"
* IBM 704 - computer
* IBM 709 - almost compatible with the 704, the I/O is entirely different
* JCL - OS/360 Job Control Language, based on asm lang for System/360 under the assumption that everyone knows asm, however that is an awkward choice for a job control lang; uses whitespace to start a comment, which leads to bad parses
* JOVIAL - lang derived from ALGOL; "Jules' Own Version of Algol"
* Lisp - lang
* MYSTIC - crap lang, lost to history
* Nim - terminal game
* PL/I - lang, apparently better than Fortran; beware math (floating) versus arithmetic (integer) libs
* Short Code - early interpreted lang from 1950, used a style similar to hand-rolled bytecode
* Simula - lang
* SNOBOL - lang
* Spacewar - terminal game
* Vienna Definition Language - describes langs, worked on by Heinz Zemanek IBM team

# Names Dropped

* Abraham Lincoln - riddle: if we call a tail a leg, how many legs does a dog have? four, since calling it a leg doesn't make it a leg
* ACM Special Interest Group on Personnel Research - loose association studying programming from the perspective of management concerns (ie. hiring and training)
* Ada Lovelace - conceived of programming langs in 1846
* Albert Einstein - "The important thing is to never stop questioning."
* Ambrose Bierce - myths are the sacred beliefs of other people
* Bertrand Russel - "I am allowed to use plain English because everybody knows that I could use mathematical logic if I choose"
* Bertrand Russel - faith is belief in something for which there is no evidence
* Bill Gates - perhaps the best programmer in the world, if your success measure is money earned
* Brian Pioreck - "I don’t know how Peopleware became a best seller. I never run into any managers who have read it. Beyond that, I hardly run into any managers who read about their industry, management theory, or psychology, period. I used to believe that they were overloaded with information regarding the specifics of their job, but frankly, managers still aren’t trained, or do not educate themselves, to do their jobs."
* Brian Pioreck - member of the 1998 Software Engineering Management Development Group
* Brueghel - painted The Tower of Babel
* Bruner - six functions of natural lang: emotive (conveys emotional state), connotative (instructions), referential (bears factual information), meta-lingual (about language itself), poetic (esthetic), phatic (placeholder utterances)
* Byran Higram - states that every lang must have an unambiguous grammar; but is that assumption true?
* CAR Hoare - dismissive of the challenge of management, directly contradicts Joel Aron's findings; "Basically all problems are technical. If you know what you want to do and you have the necessary technical background, there is no point in making a great management problem out of it."
* David B. Mayer - studied programmer vocational personality in 1968, concluded that programmers are more conservative on average
* Deacon's Masterpiece - poem by Oliver Wendell Holmes Sr. about the "wonderful one-hoss shay, that was built in such a logical way, it ran a hundred years to a day"
* Festinger - studied cognitive dissonance
* Gerald Weinberg - author, "My greatest contribution to computing is that I never invented a programming language." the "King of Programming Languages" (he now acknowledges his role as a meta-designer of langs)
* Herb Leeds - tech writer
* Hockett - defines design features of natural language
* IBM Systems Research Institute - this book includes research from here
* Isabel Briggs Meyers - creator of the MBTI personality test
* James Clerk Maxwell - "To measure is to know."
* Jean Sammet - a COBOL designer, said COBOL was intended to be friendly and not necessarily designed for professionals
* Joel Aron - holds that most software projects fail, and typically due to challenges of management rather than lacking technical capabilities
* John von Neumann - early example of an egoless programmer; tended to be self-deprecating
* Jonas Salk - virologist
* Kevin Iverson - inventor of APL
* Lord Kelvin - "I can state flatly that heavier than air flying machines are impossible."
* Louis Pasteur - chemist
* Malraux - it is the work of a lifetime to make a man
* Marty Goetz - brought a legal challenge in the 1960s against the practice of selling software bundled with hardware as IBM did at the time, made it easier to sell or rent software on its own
* Okimoto - 1970 study looked at how erroneous comments make it harder to spot bugs in code
* Oscar Wilde - boasted that he could discourse on any topic for a half-hour without advance preparation
* Peter Kropotkin - acting on the principle of command and discipline versus acting on the principle of common understanding
* Programmer Group vs Team - the group share common resources (office, systems) but are not learning together, whereas the team is motivated to support each others activities towards the common goal
* SHARE Org - distributed some tools made for IBM hardware
* Sigmund Freud - notes the importance of introspection, self-analysis
* Sophocles - Greek writer
* State University of New York - this book includes research from here
* Tom Glib - tech writer
* Virginia Satir - family therapist; preventing a crisis is typically easier than handling one
* Virginia Satir - studied incongruent personality stances, behaviour under stress
* William James - founder of American psychology

# Publications

* A General Introduction to Psychoanalysis - Sigmund Freud
* A Scientist Looks at Pyramids - Kurt Mendelsson article in American Scientist; the need for pyramids lead to the invention of the state nation, which in turn increased demand for pyramids
* A Theory of Cognitive Dissonance - Festinger book
* An Organic Architecture - Frank Lloyd Wright book
* Becoming a Technical Leader - Weinberg book
* Charles Babbage and His Calculating Engines - Morrison, Philip, Emily, 1961 Dover book
* cyber-dojo.org - John Jagger web site, coding exercises
* Elements of Psychology - Krech, Crutchfeld, Livson book
* Fourth Generation Computers: User Requirements and Transition - Fred Gruenberger book
* High-Level COBOL Programming - book about MetaCOBOL by Gerald Weinberg
* How to Solve It - George Polya book, 1946
* Humanized Input - book by Weinberg and Tom Glib
* Man-Computer Problem Solving: Experimental Evaluation of Time-Sharing and Batch Processing - book by Sackman
* Parkison's Law - Northcote Parkinson book
* Peopleware - DeMarco and Lister book
* PL/I Language Log - IBM internal doc, spec for the PL/I lang
* PL/I Programming: A Manual of Style - Weinberg book
* Planning a Computer System: Project Stretch - book by Werner Bucholz
* Programming Languages: History and Fundamentals - book by Jean Sammet
* Programming Languages: History and Fundamentals - book by Jean Sammet
* Quality Software Management series - by the author
* Rethinking Systems Analysis and Design - book
* The Genetical Theory of Natural Selection - Ronald Fisher book
* The Image of the City - Kevin Lynch book
* The Political Philosophy of Bakunin - Mikhail Bakunin book
* The Presentation of Self in Everyday Life - Erving Goffman book
* The Silent Language - Edward Hall book
* The Social Psychology of Industry - J.A.C. Brown, about Industrial Psychology
* Understanding the Professional Programmer - book
* Use of Psychological Tests in the Selection of Computer Personnel - Mayer and Stalnaker book, 1968
